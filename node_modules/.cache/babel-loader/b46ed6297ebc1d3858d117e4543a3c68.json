{"ast":null,"code":"class ListNode {\n  constructor(subject, amount) {\n    this.nextNode = null;\n    this.subject = subject;\n    this.amount = Number(amount);\n  }\n\n  show() {\n    return {\n      subject: this.subject,\n      amount: this.amount\n    };\n  }\n\n} // ---------------------\n\n\nclass LinkedList {\n  constructor() {\n    // Does not need any Input properties\n    this.current = null;\n    this.headNode = null; // this.nextNode = null;\n\n    this.listAmount = 0;\n  }\n\n  showList() {\n    const storedLocn = this.current; // set .\n\n    this.first();\n    const outputArr = [];\n\n    while (this.current.nextNode !== null) {\n      // while (!this.current.nextNode) {\n      outputArr.push([this.current.subject, this.current.amount, this.current.nextNode.subject]);\n      this.next();\n    }\n\n    this.next();\n    outputArr.push([this.current.subject, this.current.amount, \"null\"]); // console.log(outputArr);\n\n    this.current = storedLocn;\n    return outputArr;\n  }\n\n  first() {\n    // directly set to the head Node\n    this.current = this.headNode;\n    return this.current;\n  }\n\n  prev() {\n    if (this.current !== this.headNode) {\n      const startLoc = this.current;\n      this.first(); // go to top\n\n      while (this.current.nextNode !== startLoc) {\n        // console.log(\"Prev/head\", this.headNode);\n        // console.log(\"Prev/startLoc\", this.headNode);\n        this.next(); // this.current = this.current.nextNode;\n      }\n    }\n\n    return this.current;\n  }\n\n  last() {\n    // if nextnode is !null for the current Node  keep doing next()\n    while (this.current.nextNode) {\n      // console.log(this.current);\n      this.next(); // console.log(this.current);\n    }\n\n    return this.current;\n  }\n\n  next() {\n    // debugger;\n    if (this.current.nextNode) {\n      this.current = this.current.nextNode;\n    }\n\n    return this.current;\n  }\n\n  add(subject, amount) {\n    // const prevNode = this.current;\n    const node = new ListNode(subject, amount);\n    this.listAmount += Number(node.amount);\n\n    if (!this.headNode) {\n      // list is empty\n      this.current = node;\n      this.headNode = node; // return (this.current = this.headNode = node);\n    } else {\n      // first set where the current next node to the new node as it is inserted between existing nodes\n      node.nextNode = this.current.nextNode;\n      this.current.nextNode = node;\n      this.current = node;\n    }\n\n    return this.current;\n  } //add\n\n\n  delete() {\n    // only do something if list not empty\n    if (this.headNode) {\n      let marker = this.current;\n      this.listAmount -= Number(marker.amount); // if deleting the head\n\n      if (this.current === this.headNode) {\n        // console.log(\"Deleting HeadNode\");\n        this.current = this.current.nextNode;\n        this.headNode = this.current; // return this.current;\n      } else if (this.current.nextNode !== null) {\n        // if deleting intermediate  ones\n        // current s next node is null, ie not the last entry\n        // console.log(\"Deleting Intermediate Node\");\n        // set Prev node's next node to this nextnode\n        this.prev();\n        this.current.nextNode = this.current.nextNode.nextNode; // return (this.current = prevNode); // return the previous node to be consistnt  with the last Node removal action\n      } else {\n        //if deleting End Node\n        // if (this.current !== this.headNode && this.current.nextNode == null)\n        // console.log(\"Deleting Last Node\");\n        this.prev();\n        this.current.nextNode = this.current.nextNode.nextNode;\n      }\n    }\n\n    return this.current;\n  }\n\n}\n\nexport { ListNode, LinkedList };","map":{"version":3,"sources":["C:/code/cohort3/react-03/react-03/src/components/Linklist/LLfunctions.js"],"names":["ListNode","constructor","subject","amount","nextNode","Number","show","LinkedList","current","headNode","listAmount","showList","storedLocn","first","outputArr","push","next","prev","startLoc","last","add","node","delete","marker"],"mappings":"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","sourcesContent":["class ListNode {\r\n  constructor(subject, amount) {\r\n    this.nextNode = null;\r\n    this.subject = subject;\r\n    this.amount = Number(amount);\r\n  }\r\n  show() {\r\n    return { subject: this.subject, amount: this.amount };\r\n  }\r\n}\r\n// ---------------------\r\nclass LinkedList {\r\n  constructor() {\r\n    // Does not need any Input properties\r\n    this.current = null;\r\n    this.headNode = null;\r\n    // this.nextNode = null;\r\n    this.listAmount = 0;\r\n  }\r\n  showList() {\r\n    const storedLocn = this.current;\r\n    // set .\r\n    this.first();\r\n    const outputArr = [];\r\n    while (this.current.nextNode !== null) {\r\n      // while (!this.current.nextNode) {\r\n      outputArr.push([\r\n        this.current.subject,\r\n        this.current.amount,\r\n        this.current.nextNode.subject\r\n      ]);\r\n\r\n      this.next();\r\n    }\r\n    this.next();\r\n    outputArr.push([this.current.subject, this.current.amount, \"null\"]);\r\n\r\n    // console.log(outputArr);\r\n    this.current = storedLocn;\r\n    return outputArr;\r\n  }\r\n\r\n  first() {\r\n    // directly set to the head Node\r\n    this.current = this.headNode;\r\n    return this.current;\r\n  }\r\n\r\n  prev() {\r\n    if (this.current !== this.headNode) {\r\n      const startLoc = this.current;\r\n      this.first(); // go to top\r\n      while (this.current.nextNode !== startLoc) {\r\n        // console.log(\"Prev/head\", this.headNode);\r\n        // console.log(\"Prev/startLoc\", this.headNode);\r\n        this.next();\r\n        // this.current = this.current.nextNode;\r\n      }\r\n    }\r\n\r\n    return this.current;\r\n  }\r\n\r\n  last() {\r\n    // if nextnode is !null for the current Node  keep doing next()\r\n    while (this.current.nextNode) {\r\n      // console.log(this.current);\r\n      this.next();\r\n      // console.log(this.current);\r\n    }\r\n    return this.current;\r\n  }\r\n\r\n  next() {\r\n    // debugger;\r\n    if (this.current.nextNode) {\r\n      this.current = this.current.nextNode;\r\n    }\r\n\r\n    return this.current;\r\n  }\r\n\r\n  add(subject, amount) {\r\n    // const prevNode = this.current;\r\n    const node = new ListNode(subject, amount);\r\n    this.listAmount += Number(node.amount);\r\n    if (!this.headNode) {\r\n      // list is empty\r\n      this.current = node;\r\n      this.headNode = node;\r\n      // return (this.current = this.headNode = node);\r\n    } else {\r\n      // first set where the current next node to the new node as it is inserted between existing nodes\r\n\r\n      node.nextNode = this.current.nextNode;\r\n      this.current.nextNode = node;\r\n      this.current = node;\r\n    }\r\n    return this.current;\r\n  } //add\r\n\r\n  delete() {\r\n    // only do something if list not empty\r\n    if (this.headNode) {\r\n      let marker = this.current;\r\n      this.listAmount -= Number(marker.amount);\r\n\r\n      // if deleting the head\r\n      if (this.current === this.headNode) {\r\n        // console.log(\"Deleting HeadNode\");\r\n        this.current = this.current.nextNode;\r\n        this.headNode = this.current;\r\n        // return this.current;\r\n      } else if (this.current.nextNode !== null) {\r\n        // if deleting intermediate  ones\r\n\r\n        // current s next node is null, ie not the last entry\r\n        // console.log(\"Deleting Intermediate Node\");\r\n        // set Prev node's next node to this nextnode\r\n        this.prev();\r\n        this.current.nextNode = this.current.nextNode.nextNode;\r\n\r\n        // return (this.current = prevNode); // return the previous node to be consistnt  with the last Node removal action\r\n      } else {\r\n        //if deleting End Node\r\n        // if (this.current !== this.headNode && this.current.nextNode == null)\r\n\r\n        // console.log(\"Deleting Last Node\");\r\n        this.prev();\r\n        this.current.nextNode = this.current.nextNode.nextNode;\r\n      }\r\n    }\r\n    return this.current;\r\n  }\r\n}\r\n\r\nexport { ListNode, LinkedList };\r\n"]},"metadata":{},"sourceType":"module"}